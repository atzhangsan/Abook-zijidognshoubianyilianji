合纵缔交，相与为一。<br>
                      ——《史记》<br>
    在编译系统中，链接器扮演类似“胶水”的角色。它把汇编器处理生成的可重定位目标文件黏合、拼接为一个可执行的ELF文件。
 然而，链接器并非机械地拼接目标文件，它还需要完成汇编阶段无法完成的段地址分配、符号地址计算以及数据/指令内容修正的工作。
 这三个主要任务涉及了链接器工作的核心流程：地址空间分配、符号解析和重定位。<br>
    在可重定位目标文件的段表项中，段的虚拟地址都是默认设为0。这是因为在汇编器处理阶段，是不可能知道段的加载地址的。<br>
链接器的地址空间分配操作的主要目的是为段指定加载地址。
    在确定了段加载地址（简称段基址）后，根据目标文件内符号的段内偏移地址，可以计算得到符号的虚拟地址（简称符号地址）。
链接器的符号解析操作并不止于计算符号地址，它还需要分析目标文件之间的符号引用的情况，计算目标文件内引用的外部符号的地址。<br>
符号解析之后，所有目标文件的符号地址都已经确定。链接器通过重定位操作，修正代码段或数据段内引用的符号地址。<br>
    最后，链接器将以上操作处理后的文件信息导出为可执行ELF文件，完成链接的工作。<br>
    参考图2-17描述的链接器的结构设计，我们在本章详细阐述链接器每个功能模块的实现。<br>

##7.1 信息收集<br>

对链接器来说，其输入是一系列的可重定位目标文件。链接器欲完成后续的工作，必须逐个扫描目标文件，提取需要的信息进行处理。因此，我们需要建立必要的数据结构缓存链接器需要的信息。<br>
##7.1.1目标文件信息
首先，需要建立ELF文件对象，保存扫描的目标文件信息。第6章已经构建了Elf_file对象，不过该对象的主要功能是将ELF文件结构信息写入目标文件。而链接器需要扫描ELF文件的内容，因此需要添加必要的ELF文件读取操作。正如汇编器生成目标文件时比较关心段表、符号表、重定位表信息那样，链接器扫描目标文件时也会着重关注这三个文件结构的信息。参考第6章对ELF目标文件结构的构造方式，读取ELF目标文件结构的实现代码为：<br>
```
1  void Elf_file::readElf(const string dir) {
2         //打开目标文件
3         elf_dir=dir;
4         FILE*fp=fopen(elf_dir.c_str(),"rb");
5
6           //文件头
7         rewind(fp);
8         fread(&ehdr,sizeof(Elf32_Ehdr),1,fp);
9
10          //程序头表
11        if(ehdr.e_type==ET_EXEC) {
12               fseek(fp,ehdr.e_phoff,0);
13               for(int i=0;i<ehdr.e_phnum;++i) {
14                      Elf32_Phdr*phdr=new Elf32_Phdr();
15                      fread(phdr,ehdr.e_phentsize,1,fp);
16                      phdrTab.push_back(phdr);
17               }
18        }
19
20          //.shstrtab表项
21        Elf32_Shdr shstrTab;
22        fseek(fp,ehdr.e_shoff+ehdr.e_shentsize*ehdr.e_shstrndx,0);
23        fread(&shstrTab,ehdr.e_shentsize,1,fp);
24
25          //.shstrtab
26        char*shstrTabData=new char[shstrTab.sh_size];
27        fseek(fp,shstrTab.sh_offset,0);
28        fread(shstrTabData,shstrTab.sh_size,1,fp);
29
30          //段表
31        fseek(fp,ehdr.e_shoff,0);
32        for(int i=0;i<ehdr.e_shnum;++i) {
33               Elf32_Shdr*shdr=new Elf32_Shdr();
34               fread(shdr,ehdr.e_shentsize,1,fp);
35               string name(shstrTabData+shdr->sh_name);
36               shdrNames.push_back(name);
37               shdrTab[name]=shdr;
38        }
39
40          //.strtab
41        Elf32_Shdr *strTab=shdrTab[".strtab"];
42        char*strTabData=new char[strTab->sh_size];
43        fseek(fp,strTab->sh_offset,0);
44        fread(strTabData,strTab->sh_size,1,fp);
45
46          //.symtab
47        Elf32_Shdr *sh_symTab=shdrTab[".symtab"];
48        fseek(fp,sh_symTab->sh_offset,0);
49        int symNum=sh_symTab->sh_size/sh_symTab->sh_entsize;
50        for(int i=0;i<symNum;++i) {
51               Elf32_Sym*sym=new Elf32_Sym();
52               fread(sym,sh_symTab->sh_entsize,1,fp);
53               string name(strTabData+sym->st_name);
54               symNames.push_back(name);
55               symTab[name]=sym;
56        }
57
58          //.rel.data .rel.text
59        for(int i=0;i<shdrNames.size();i++) {
60               string shdrName = shdrNames[i];
61                Elf32_Shdr*shdr=shdrTab[shdrName];
62               if(shdr->sh_type==SHT_REL) {
63                       fseek(fp,shdr->sh_offset,0);
64                       int relNum=shdr->sh_size/shdr->sh_entsize;
65                      for(int j=0;j<relNum;++j) {
66                             Elf32_Rel*rel=new Elf32_Rel();
67                             fread(rel,shdr->sh_entsize,1,fp);
68                             string segName=shdrNames[shdr->sh_info];
69                             string symName=symNames[ELF32_R_SYM(rel->r_info)];
70                             relTab.push_back(new RelItem(segName,rel,symName));
71                      }
72               }
73        }
74
75        delete []shstrTabData;
76        delete []strTabData;
77        fclose(fp);
78 }
```
我们使用readElf函数读取ELF文件的信息。<br>
1）第2~4行打开目标文件，并将文件路径记录到elf_dir。<br>
2）第6~8行读取ELF文件头的信息到ehdr。<br>
3）第10~18行读取程序头表的信息。虽然目标文件没有该文件结构，但我们还是实现了这部分的逻辑。即从文件的e_phoff偏移处，读取e_phentsize个Elf32_Phdr对象，保存到phdrTab列表即可。<br>
4）第20~23行读取段表字符串表“.shstrtab”的段表项信息，根据e_shstrndx字段以及段表偏移和段表项大小，可计算得到“.shstrtab”的位置，然后取出该段表项对应的Elf32_Shdr对象shstrTab。<br>
5）第25~28行读取段表字符串表“.shstrtab”的数据内容。即根据段表项shstrTab记录的段偏移sh_offset和段大小sh_size，读取数据到字符缓冲区shstrTabData。<br>
6）第30~38行读取段表的信息。即从文件的e_shoff偏移处，读取e_shentsize个Elf32_Shdr对象，保存到shdrTab表即可。其中段名可以从shstrTabData的sh_name位置获得，我们将段名按序保存到段名列表shdrNames，以方便段表项的按索引访问。<br>
7）第40~44行读取字符串表“.strtab”的数据内容。即根据段表项记录的段偏移sh_offset和段大小sh_size，将文件中的内容读取到字符缓冲区strTabData。理论上，对字符串表的访问方式应该是根据段表中扫描到的重定位表项（段类型为SHT_REL）的sh_link字段得到重定位表引用的符号表的段表索引，继而取出符号表的段表项，然后根据符号表的段表项的sh_link字段得到符号表引用的字符串表的段索引，最终得到字符串表的数据内容。不过，我们很清楚在汇编器生成的目标文件内只有唯一一个“.strtab”段，这里直接按名访问是一种简化的方式，后面对符号表的访问与此类似。<br>
8）第46~56行读取符号表“.symtab”的信息。即从段表项记录的sh_offset位置，读取sh_size/sh_entsize个Elf32_Shdr对象，保存到symTab。其中符号名从strTabData的st_name位置获得，我们将符号名按序保存到符号名列表symNames，以方便符号表项的按索引访问。<br>
9）第58~73行读取重定位表的信息。通过遍历取出段类型为SHT_REL的段表项，从段表项记录的sh_offset位置，读取sh_size/sh_entsize个Elf32_Rel对象。对于每个重定位表项rel，根据当前段的sh_info从shdrNames内取得重定位段名segName，根据重定位表项的r_info取出重定位符号在符号表内的索引，继而从symNames内取得重定位符号名symName。根据以上信息构造RelItem对象，保存到relTab表即可。<br>












