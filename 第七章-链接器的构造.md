第七章
=====
合纵缔交，相与为一。<br>
                      ——《史记》<br>
    在编译系统中，链接器扮演类似“胶水”的角色。它把汇编器处理生成的可重定位目标文件黏合、拼接为一个可执行的ELF文件。
 然而，链接器并非机械地拼接目标文件，它还需要完成汇编阶段无法完成的段地址分配、符号地址计算以及数据/指令内容修正的工作。
 这三个主要任务涉及了链接器工作的核心流程：地址空间分配、符号解析和重定位。<br>
    在可重定位目标文件的段表项中，段的虚拟地址都是默认设为0。这是因为在汇编器处理阶段，是不可能知道段的加载地址的。<br>
链接器的地址空间分配操作的主要目的是为段指定加载地址。
    在确定了段加载地址（简称段基址）后，根据目标文件内符号的段内偏移地址，可以计算得到符号的虚拟地址（简称符号地址）。
链接器的符号解析操作并不止于计算符号地址，它还需要分析目标文件之间的符号引用的情况，计算目标文件内引用的外部符号的地址。<br>
符号解析之后，所有目标文件的符号地址都已经确定。链接器通过重定位操作，修正代码段或数据段内引用的符号地址。<br>
    最后，链接器将以上操作处理后的文件信息导出为可执行ELF文件，完成链接的工作。<br>
    参考图2-17描述的链接器的结构设计，我们在本章详细阐述链接器每个功能模块的实现。<br>

##7.1 信息收集
--------------

对链接器来说，其输入是一系列的可重定位目标文件。链接器欲完成后续的工作，必须逐个扫描目标文件，提取需要的信息进行处理。因此，我们需要建立必要的数据结构缓存链接器需要的信息。<br>
##7.1.1目标文件信息
首先，需要建立ELF文件对象，保存扫描的目标文件信息。第6章已经构建了Elf_file对象，不过该对象的主要功能是将ELF文件结构信息写入目标文件。而链接器需要扫描ELF文件的内容，因此需要添加必要的ELF文件读取操作。正如汇编器生成目标文件时比较关心段表、符号表、重定位表信息那样，链接器扫描目标文件时也会着重关注这三个文件结构的信息。参考第6章对ELF目标文件结构的构造方式，读取ELF目标文件结构的实现代码为：<br>
```
void Elf_file::readElf(const char *dir)
{
	string d=dir;
	elf_dir=new char[d.length()+1];
	strcpy(elf_dir,dir);
	FILE*fp=fopen(dir,"rb");
	rewind(fp);
	fread(&ehdr,sizeof(Elf32_Ehdr),1,fp);//读取文件头

	if(ehdr.e_type==ET_EXEC)//可执行文件拥有程序头表
	{
		fseek(fp,ehdr.e_phoff,0);//程序头表位置
		for(int i=0;i<ehdr.e_phnum;++i)//读取程序头表
		{
			Elf32_Phdr*phdr=new Elf32_Phdr();
			fread(phdr,ehdr.e_phentsize,1,fp);//读取程序头
			phdrTab.push_back(phdr);//加入程序头表
		}
	}

	fseek(fp,ehdr.e_shoff+ehdr.e_shentsize*ehdr.e_shstrndx,0);//段表字符串表位置
	Elf32_Shdr shstrTab;
	fread(&shstrTab,ehdr.e_shentsize,1,fp);//读取段表字符串表项
	char*shstrTabData=new char[shstrTab.sh_size];
	fseek(fp,shstrTab.sh_offset,0);//转移到段表字符串表内容
	fread(shstrTabData,shstrTab.sh_size,1,fp);//读取段表字符串表
	//for(int i=0;i<shstrTab.sh_size;i++)printf("%c",shstrTabData[i]);printf("\t--shstrTab\n");

	fseek(fp,ehdr.e_shoff,0);//段表位置
	for(int i=0;i<ehdr.e_shnum;++i)//读取段表
	{
		Elf32_Shdr*shdr=new Elf32_Shdr();
		fread(shdr,ehdr.e_shentsize,1,fp);//读取段表项[非空]
		string name(shstrTabData+shdr->sh_name);
		shdrNames.push_back(name);//记录段表名位置
		if(name.empty())
			delete shdr;//删除空段表项
		else
		{
			//printf("%s\t\t%08x\n",shstrTabData+shdr->sh_name,shdr->sh_addralign);
			shdrTab[name]=shdr;//加入段表
		}
	}
	delete []shstrTabData;//清空段表字符串表

	Elf32_Shdr *strTab=shdrTab[".strtab"];//字符串表信息
	char*strTabData=new char[strTab->sh_size];
	fseek(fp,strTab->sh_offset,0);//转移到字符串表内容
	fread(strTabData,strTab->sh_size,1,fp);//读取字符串表
	//for(int i=0;i<strTab->sh_size;i++)printf("%c",strTabData[i]);printf("\t--strTab\n");

	Elf32_Shdr *sh_symTab=shdrTab[".symtab"];//符号表信息
	fseek(fp,sh_symTab->sh_offset,0);//转移到符号表内容
	int symNum=sh_symTab->sh_size/16;//符号个数[非空],16最好用2**sh_symTab->sh_entsize代替
	vector<Elf32_Sym*>symList;//按照序列记录符号表所有信息，方便重定位符号查询
	for(int i=0;i<symNum;++i)//读取符号
	{
		Elf32_Sym*sym=new Elf32_Sym();
		fread(sym,16,1,fp);//读取符号项[非空]
		symList.push_back(sym);//添加到符号序列
		string name(strTabData+sym->st_name);
		if(name.empty())//无名符号，对于链接没有意义,按照链接器设计需要记录全局和局部符号，避免名字冲突
			delete sym;//删除空符号项
		else
		{
			//if(ELF32_ST_BIND(sym->st_info)==STB_GLOBAL)
				//printf("%s\t\t%d\n",strTabData+sym->st_name,sym->st_shndx);
			symTab[name]=sym;//加入符号表
		}
	}
	if(showLink)
		printf("----------%s重定位数据:----------\n",elf_dir);
	for(hash_map<string, Elf32_Shdr*,string_hash>::iterator i=shdrTab.begin();i!=shdrTab.end();++i)//所有段的重定位项整合
	{
		if(i->first.find(".rel")==0)//是重定位段
		{
			Elf32_Shdr *sh_relTab=shdrTab[i->first];//重定位表信息
			fseek(fp,sh_relTab->sh_offset,0);//转移到重定位表内容
			int relNum=sh_relTab->sh_size/8;//重定位项数
			for(int j=0;j<relNum;++j)
			{
				Elf32_Rel*rel=new Elf32_Rel();
				fread(rel,8,1,fp);//读取重定位项
				string name(strTabData+symList[ELF32_R_SYM(rel->r_info)]->st_name);//获得重定位符号名字
				//使用shdrNames[sh_relTab->sh_info]访问目标段更标准
				relTab.push_back(new RelItem(i->first.substr(4),rel,name));//添加重定位项
				if(showLink)
					printf("%s\t%08x\t%s\n",i->first.substr(4).c_str(),rel->r_offset,name.c_str());
			}
		}
	}
	delete []strTabData;//清空字符串表

	fclose(fp);
}
```
我们使用readElf函数读取ELF文件的信息。<br>
1）第2~4行打开目标文件，并将文件路径记录到elf_dir。<br>
2）第6~8行读取ELF文件头的信息到ehdr。<br>
3）第10~18行读取程序头表的信息。虽然目标文件没有该文件结构，但我们还是实现了这部分的逻辑。即从文件的e_phoff偏移处，读取e_phentsize个Elf32_Phdr对象，保存到phdrTab列表即可。<br>
4）第20~23行读取段表字符串表“.shstrtab”的段表项信息，根据e_shstrndx字段以及段表偏移和段表项大小，可计算得到“.shstrtab”的位置，然后取出该段表项对应的Elf32_Shdr对象shstrTab。<br>
5）第25~28行读取段表字符串表“.shstrtab”的数据内容。即根据段表项shstrTab记录的段偏移sh_offset和段大小sh_size，读取数据到字符缓冲区shstrTabData。<br>
6）第30~38行读取段表的信息。即从文件的e_shoff偏移处，读取e_shentsize个Elf32_Shdr对象，保存到shdrTab表即可。其中段名可以从shstrTabData的sh_name位置获得，我们将段名按序保存到段名列表shdrNames，以方便段表项的按索引访问。<br>
7）第40~44行读取字符串表“.strtab”的数据内容。即根据段表项记录的段偏移sh_offset和段大小sh_size，将文件中的内容读取到字符缓冲区strTabData。理论上，对字符串表的访问方式应该是根据段表中扫描到的重定位表项（段类型为SHT_REL）的sh_link字段得到重定位表引用的符号表的段表索引，继而取出符号表的段表项，然后根据符号表的段表项的sh_link字段得到符号表引用的字符串表的段索引，最终得到字符串表的数据内容。不过，我们很清楚在汇编器生成的目标文件内只有唯一一个“.strtab”段，这里直接按名访问是一种简化的方式，后面对符号表的访问与此类似。<br>
8）第46~56行读取符号表“.symtab”的信息。即从段表项记录的sh_offset位置，读取sh_size/sh_entsize个Elf32_Shdr对象，保存到symTab。其中符号名从strTabData的st_name位置获得，我们将符号名按序保存到符号名列表symNames，以方便符号表项的按索引访问。<br>
9）第58~73行读取重定位表的信息。通过遍历取出段类型为SHT_REL的段表项，从段表项记录的sh_offset位置，读取sh_size/sh_entsize个Elf32_Rel对象。对于每个重定位表项rel，根据当前段的sh_info从shdrNames内取得重定位段名segName，根据重定位表项的r_info取出重定位符号在符号表内的索引，继而从symNames内取得重定位符号名symName。根据以上信息构造RelItem对象，保存到relTab表即可。<br>

##7.1.2端数据信息
通过读取ELF可重定位目标文件，可以将待链接的目标文件信息保存起来。然而，链接器处理的对象其实是目标文件内保存的二进制程序或数据，如代码段“.text”和数据段“.data”的内容。因此，需要定义相关的数据结构以保存目标文件内的二进制信息，辅助链接器的工作。为了保持描述的一致性，本书将段内保存的二进制信息统称为段数据。
```
1  //数据块
2  struct Block {
3         char *data;                                                               //块数据
4         unsigned int offset;                                          //块偏移
5         unsigned int size;                                                 //块大小
6  };
7
8  //同类型段列表
9  struct SegList {
10        unsigned int baseAddr;                                          //基地址
11        unsigned int begin;                                                 //对齐前偏移
12        unsigned int offset;                                          //对齐后偏移
13        unsigned int size;                                                 //总大小
14        vector<Elf_file*>ownerList;                                   //所有者文件
15        vector<Block*>blocks;                                          //数据块
16
17        void allocAddr(string name,unsigned int& base,
18                     unsigned int& off);
19        void relocAddr(unsigned int relAddr,
20                     unsigned char type,unsigned int symAddr);
21 };
22
23 hash_map<string,SegList*,string_hash>segLists;       //所有合并段列表
```
1）第1~6行定义Block类保存段数据的信息，其中data表示数据块的地址，offset表示数据块经过链接器处理后在可执行文件内的偏移，size表示数据块的大小。由于链接器在重定位阶段需要段数据内容，因此Block保存的数据块为重定位操作提供了数据载体。
2）第9~21行定义SegList类保存同类型段的数据块和相关信息。其中baseAddr表示链接器为合并后的段分配的虚拟段基地址，begin表示合并后的段在对齐之前的文件偏移，offset表示对齐后的文件偏移，size表示合并后的段大小，ownerList表示包含该类型段的目标文件列表，blocks表示所有的当前段类型的段数据列表。函数allocAddr用于段的地址空间分配操作，relocAddr用于重定位操作。SegList对象保存的信息方便了链接器的段地址空间分配工作。
3）第23行定义的segLists对象保存了所有类型的SegList对象。由于在汇编器阶段仅生成了两种类型的段：“.text”段和“.data”段，因此在简化的链接器的实现中，segLists对象其实只有两个元素。
为了方便对段数据信息相关数据结构的理解，我们使用一个简单的例子说明。
如图7-1所示，链接器会将同名的段合并，如“.text”段和“.data”段。深色部分表示目标文件内段的二进制数据，Block对象会记录该数据的内容、大小以及合并后的偏移。比如目标文件a.o和b.o的“.text”段会被合并为可执行文件的“.text”段。合并后的段内包含原始的段内二进制数据和因为段对齐产生的段内填充数据。段内对齐会根据目标文件内保存的段对齐字段sh_align进行，如文件b.o的“.text”的偏移会根据4字节对齐。合并后的段也需要根据可执行文件对段的对齐要求进行对齐，如最终的“.text”段的偏移会按照链接器要求的16字节进行对齐（其他类型的段，如数据段仍是按照4字节对齐）对齐前的文件偏移保存在SegList：：begin内，以方便可执行文件生成时对段间的间隙进行填充。
##7.1.3符号引用信息

除了对目标文件的段数据进行重新组织，链接器还需要分析目标文件内符号的引用情况。之所以要分析符号的引用信息，是因为在链接器处理的目标文件中，存在未定义的符号，即对其他目标文件符号的引用。为了方便链接器符号解析的处理，一般会定义两个符号集合：一个是导出符号集合，表示所有目标文件内定义的可以被其他目标引用的全局符号集合；另一个是导入符号集合，表示所有目标文件未定义却引用其他目标文件的符号集合。<br>
```

1  //符号引用对象
2  struct SymLink {
3         string name;                                          //符号名
4         Elf_file*recv;                                          //引用符号文件
5         Elf_file*prov;                                          //提供符号的文件
6  };
7
8  vector<SymLink*>symLinks;                            //所有符号引用信息
9  vector<SymLink*>symDef;                                   //所有符号定义信息

```


1）第1~6行定义了SymLink对象记录符号引用的信息，其中name为符号名，recv为引用符号的目标文件，prov为定义符号的目标文件。
2）第8~9行的symLinks表示导入符号的集合，symDef表示导出符号集合。
如图7-2所示，在目标文件a.o内定义了全局符号var和main，在目标文件b.o内定义了全局符号ext和fun，这些符号所在的段已经在符号名前标明，链接器会将这四个全局符号放入导出符号集合。另外，目标文件a.o的符号表内还保存了未定义符号ext和fun，目标文件b.o的符号表内也保存了未定义符号var，链接器将这三个未定义符号放入导入符号集合。经过链接器的符号解析处理后，会为每个导入符号找到定义它的目标文件。例如，a.o中ext和fun符

号的定义在b.o文件内，以及b.o中var符号的定义在a.o文件内。

##7.2地址空间分配
汇编器生成目标文件时，由于无法确定段的加载地址，因此默认将段基址设置为0。链接器的第一步工作便是确定需要加载段的段基址，为待加载段指定段基址的过程称为地址空间分配。
链接器为段指定基址，需要从三个方面进行考虑。
1）段加载的起始地址。该地址是所有加载段的起始位置，在32位Linux系统中，一般设置为0x08048000。
2）段的拼接顺序。链接器按序扫描目标文件内同名的段，并将段的二进制数据依次“摆放”。在我们实现的链接器中，只需要按照代码段“.text”、数据段“.data”的顺序，依次处理每个目标文件内该类型的段即可。
3）段对齐方式。段对齐包含两个层面：段文件偏移的对齐和段基址的对齐。在可重定位的目标文件内，一般将段的文件偏移对齐设置为4字节，不考虑段基址的对齐（段基址都是0，没有对齐的意义）。而在可执行文件内，会将代码段“.text”的文件偏移对齐设置为16字节，其他段的文件偏移对齐方式仍默认为4字节。而段基址的对齐则比较复杂，需要保证段的线性地址与段对应文件偏移相对于段对齐值（即页面大小，Linux下默认为4096字节）取模相等。此处可参考第5章关于程序头表内段对齐字段p_align的解释。
图7-3给出了一个地址空间分配的例子。目标文件a.o的代码段大小为0x4a字节，数据段大小为0x08字节，b.o的代码段大小为0x21字节，数据段大小为0x04字节。
首先确定段的文件偏移。根据前面的描述，链接器会将a.o的代码段、b.o的代码段、a.o的数据段、b.o的数据段依次“摆放”。基于该顺序，可以确定每个段的文件偏移。在可执行文件的代码段之前，还有文件头和程序头表结构。其中文件头占用52字节，程序头表包含两个表项（分别用于加载代码段和数据段），占用2×sizeof（Elf32_Phdr）=2×32=64字节，因此代码段的文件偏移为52+64=116字节（0x74）。考虑到可执行文件代码段的文件偏移需要按16字节对齐，因此最终确定的代码段文件偏移为0x80。基于此，确定a.o的代码段文件偏移为0x80。b.o的代码段文件偏移为0x80+0x4a=0xca，按照4字节（目标文件段表内段表项的sh_align=4）对齐后为0xcc。依此类推，得到a.o的数据段文件偏移为0xf0，b.o的数据段文件偏移为0xf8。
接着，根据段的文件偏移确定段基址。从默认的段加载起始地址0x08048000开始，计算代码段和数据段的基址。将起始地址按照页大小4096字节（0x1000）对齐为0x08048000，然后累加代码段文件偏移相对于页大小的模值0x80%0x1000=0x80，得到代码段的最终基址为0x08048080。基于此，得到a.o的代码段的基址为0x08048080，b.o的代码段的基址为0x080480cc，代码段结束位置的虚拟地址为0x080480ed。接下来处理数据段，将代码段的结束位置的虚拟地址按照页大小对齐后为0x08049000，累加数据段文件偏移相对于页大小的模值0xf0%0x1000=0xf0，得到数据段的最终基址为0x080490f0。基于此，得到a.o的数据段基址为0x080490f0，b.o的数据段基址为0x080490f8。

根据以上的描述，链接器对地址空间分配算法的实现为：
```
1  #define BASE_ADDR 0x08048000                                          //默认加载地址
2  #define MEM_ALIGN 4096                                                 //默认内存对齐大小
3  #define DISC_ALIGN 4                                                        //默认磁盘对齐大小
4  #define TEXT_ALIGN 16                                                 //.text段对齐大小
5
6  void Linker::allocAddr() {
7         unsigned int curAddr=BASE_ADDR;
8         unsigned int curOff=52+
9                sizeof(Elf32_Phdr)*segNames.size();
10      for(int i=0;i<segNames.size();++i) 
{11      segLists[segNames[i]]->allocAddr(segNames[i],
12           curAddr,curOff);
13      }
14 }
15
16  void SegList::allocAddr(string name,unsigned int& base,
17  unsigned int& off) {
18  begin=off;                                                                      //对齐前偏移
19
20  int align=DISC_ALIGN;
21  if(name==".text") align=TEXT_ALIGN;
22  off+=(align-off%align)%align;
23  base+=(MEM_ALIGN-base%MEM_ALIGN)%MEM_ALIGN
24       +off%MEM_ALIGN;
25
26  baseAddr=base;                                                               //段基址
27  offset=off;                                                                      //对齐后偏移
28  size=0;                                                                      //段大小, 段内偏移
29
30  for(int i=0;i<ownerList.size();++i) {
31       Elf32_Shdr*seg=ownerList[i]->shdrTab[name];
32       int sh_align=seg->sh_align;
33       size+=(sh_align-size%sh_align)%sh_align;
34
35       char* buf=new char[seg->sh_size];                     //段数据
36      ownerList[i]->getData(buf,seg->sh_offset,seg->sh_size);
37      blocks.push_back(new Block(buf,size,seg->sh_size));
38
39      seg->sh_addr=base+size;                                          //段基址
40      size+=seg->sh_size;                                                 //累加段内偏移
41  }
42  base+=size;                                                                      //累加基址
43  off+=size;                                                                      //累加偏移
44  }
45
46  void Elf_file::getData(char*buf,Elf32_Off offset,
47  Elf32_Word size) {
48  FILE*fp=fopen(elf_dir,"rb");
49  rewind(fp);
50  fseek(fp,offset,0);
51  fread(buf,size,1,fp);
52  fclose(fp);
53 }

```
1）第1~4行定义了链接器使用的常量：默认段加载起始地址、内存对齐大小、文件对齐大小、代码段对齐大小。
2）第6~14行是为链接器进行地址空间分配的主流程。首先将curAddr初始化为段加载起始地址（0x08048000），curOff为段起始文件偏移（ELF文件头+程序头表大小）。然后根据段名列表（包含“.text”和“.data”）对每个段类型进行地址空间分配。
3）第16~44行处理每个类型段的地址空间分配。
4）第18~28行首先将对齐前的文件偏移记录到begin字段，然后根据对齐字段align（默认为4，处理代码段时设为16）修正文件偏移off，接着使对齐段基址base与文件偏移字段相对于页大小取模的值相等，最后将以上信息保存到SegList对象的字段中。其中size字段既表示合并后段的大小，也表示处理的目标文件的段偏移。
5）第30~41行处理目标文件的段。首先取出被处理的段的段表项信息，根据段对齐字段sh_align对段偏移size对齐修正。然后调用getData函数从目标文件的sh_offset位置取出sh_size长度的数据到buf，基于这些信息构建Block对象并将其添加到数据块列表。计算段的基址并将其写回目标文件的段表项，将当前段的大小累加到段偏移size。
6）第42~43行将合并后的段大小累加到基址字段base，同时将段大小累加到文件偏移字段off，为下一个类型的SegList的地址空间分配提供起始地址和偏移信息。

7）第46~53行描述了getData函数的实现，即根据调用参数读取目标文件offset处开始长度为size的数据到缓存buf。
经过以上的处理，所有目标文件内需要加载的段基址都被计算出来，地址空间分配的工作结束。



